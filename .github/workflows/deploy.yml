name: Deploy

# Three ways to trigger:
#
# 1. Push to an env-* branch (automatic — primary GitOps flow)
#    git push origin main:env-dev      → deploys to dev
#    git push origin main:env-staging  → deploys to staging
#    git push origin main:env-prod     → deploys to prod
#
# 2. workflow_dispatch (manual button in GitHub Actions UI)
#    Actions → Deploy → Run workflow → pick environment
#
# 3. GitHub Deployment event (external orchestration)
#    gh api repos/{owner}/{repo}/deployments \
#      -f ref=main -f environment=env-dev -f auto_merge=false \
#      -F required_contexts='[]'

on:
  push:
    branches:
      - env-*
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
  deployment:

jobs:
  ##############################################################################
  # Resolve environment name and commit SHA across all three trigger types.
  # push:          branch env-dev → "dev", github.sha
  # workflow_dispatch: inputs.environment, github.sha
  # deployment:    env-dev → "dev", deployment.sha
  ##############################################################################
  setup:
    name: Parse environment
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      startsWith(github.event.deployment.environment, 'env-')
    outputs:
      env_short: ${{ steps.parse.outputs.name }}
      sha: ${{ steps.parse.outputs.sha }}
      github_environment: ${{ steps.parse.outputs.github_environment }}
      backend_env_vars: ${{ steps.envvars.outputs.backend }}

    steps:
      - id: parse
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            BRANCH="${{ github.ref_name }}"
            echo "name=${BRANCH#env-}"        >> "$GITHUB_OUTPUT"
            echo "sha=${{ github.sha }}"      >> "$GITHUB_OUTPUT"
            echo "github_environment=${BRANCH}" >> "$GITHUB_OUTPUT"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "name=${{ inputs.environment }}"                         >> "$GITHUB_OUTPUT"
            echo "sha=${{ github.sha }}"                                  >> "$GITHUB_OUTPUT"
            echo "github_environment=env-${{ inputs.environment }}"       >> "$GITHUB_OUTPUT"
          else
            ENV="${{ github.event.deployment.environment }}"
            echo "name=${ENV#env-}"                         >> "$GITHUB_OUTPUT"
            echo "sha=${{ github.event.deployment.sha }}"  >> "$GITHUB_OUTPUT"
            echo "github_environment=${ENV}"                >> "$GITHUB_OUTPUT"
          fi

      # Compute per-environment non-secret backend env vars.
      # Changing these here is the only step needed to update config — no terraform apply required.
      - id: envvars
        run: |
          case "${{ steps.parse.outputs.name }}" in
            prod)
              FRONTEND_URL="https://mwongozo.alx-ai-tools.com"
              LTT_ENV="prod"
              ;;
            staging)
              FRONTEND_URL="https://staging-mwongozo.alx-ai-tools.com"
              LTT_ENV="dev"
              ;;
            *)
              FRONTEND_URL="https://dev-mwongozo.alx-ai-tools.com"
              LTT_ENV="dev"
              ;;
          esac

          BACKEND=$(jq -cn \
            --arg env    "$LTT_ENV" \
            --arg url    "$FRONTEND_URL" \
            --arg csp    "https://imbizo.alx-ai-tools.com" \
            '[
              {"name":"LTT_ENV",                 "value":$env},
              {"name":"LTT_AUTH_ENABLED",         "value":"true"},
              {"name":"LTT_DEBUG",                "value":"false"},
              {"name":"LTT_FRONTEND_URL",         "value":$url},
              {"name":"LTT_CORS_ORIGINS",         "value":("[\"" + $url + "\"]")},
              {"name":"LTT_CSP_FRAME_ANCESTORS",  "value":$csp}
            ]')

          echo "backend=$BACKEND" >> "$GITHUB_OUTPUT"

  ##############################################################################
  # Build and push Docker images to ECR
  ##############################################################################
  build:
    name: Build images
    needs: setup
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
      ecr_backend: ${{ steps.ecr-login.outputs.registry }}/ltt-backend
      ecr_frontend: ${{ steps.ecr-login.outputs.registry }}/ltt-frontend

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.sha }}

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: eu-west-1

      - name: Login to ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Compute image tag
        id: meta
        run: echo "tag=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      - name: Build and push backend
        env:
          IMAGE: ${{ steps.ecr-login.outputs.registry }}/ltt-backend
          TAG: ${{ steps.meta.outputs.tag }}
        run: |
          docker build -f Dockerfile.backend -t "$IMAGE:$TAG" .
          docker push "$IMAGE:$TAG"

      - name: Build and push frontend
        env:
          IMAGE: ${{ steps.ecr-login.outputs.registry }}/ltt-frontend
          TAG: ${{ steps.meta.outputs.tag }}
        run: |
          docker build -f apps/web/Dockerfile -t "$IMAGE:$TAG" apps/web/
          docker push "$IMAGE:$TAG"

  ##############################################################################
  # Deploy to the target environment
  ##############################################################################
  deploy:
    name: Deploy ${{ needs.setup.outputs.env_short }}
    needs: [setup, build]
    uses: ./.github/workflows/deploy-env.yml
    with:
      environment: ${{ needs.setup.outputs.env_short }}
      github_environment: ${{ needs.setup.outputs.github_environment }}
      image_tag: ${{ needs.build.outputs.image_tag }}
      ecr_backend: ${{ needs.build.outputs.ecr_backend }}
      ecr_frontend: ${{ needs.build.outputs.ecr_frontend }}
      ecs_cluster: ltt-${{ needs.setup.outputs.env_short }}
      backend_service: ltt-${{ needs.setup.outputs.env_short }}-backend
      frontend_service: ltt-${{ needs.setup.outputs.env_short }}-frontend
      migrate_task_family: ltt-${{ needs.setup.outputs.env_short }}-migrate
      private_subnets: ${{ needs.setup.outputs.env_short == 'prod' && vars.PROD_PRIVATE_SUBNETS || needs.setup.outputs.env_short == 'staging' && vars.STAGING_PRIVATE_SUBNETS || vars.DEV_PRIVATE_SUBNETS }}
      ecs_security_group: ${{ needs.setup.outputs.env_short == 'prod' && vars.PROD_ECS_SG_ID || needs.setup.outputs.env_short == 'staging' && vars.STAGING_ECS_SG_ID || vars.DEV_ECS_SG_ID }}
      backend_env_vars: ${{ needs.setup.outputs.backend_env_vars }}
    secrets:
      aws_role_arn: ${{ secrets.AWS_ROLE_ARN }}
